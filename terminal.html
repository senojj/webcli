<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        canvas {
            background-color: #000000;
        }
    </style>
</head>
<body>
<canvas id="terminal"></canvas>
<script>
    let fs = {
        type: 'd',
        nodes: {
            'home': {
                type: 'd',
                nodes: {
                    'about': {
                        type: 'f',
                        content: 'this is about me'
                    },
                    'friends': {
                        type: 'd',
                        nodes: {
                            'Rachael': {
                                type: 'f',
                                content: 'this is about Rachael'
                            }
                        }
                    }
                }
            }
        }
    };

    let history = '';
    let dir = '/home';
    let prefix = function () {
        return dir.substring(dir.lastIndexOf('/')) + '> ';
    };
    let text = prefix();
    let commands = [];
    let cmdpos = 0;

    function write_line(str) {
        history += (str + '\n');
    }

    function write(str) {
        history += str;
    }

    function resolve_path(current_path, path) {
        if (current_path === path) {
            return path;
        }
        let keys = path.split('/');
        let path_parts = current_path.split('/');
        for (let i = 0; i < keys.length; i++) {
            switch (keys[i]) {
                case '.':
                    break;
                case '..':
                    if (path_parts.length > 0) {
                        path_parts.pop();
                    }
                    break;
                case '':
                    if (i === 0) {
                        path_parts = [''];
                    }
                    break;
                default:
                    path_parts.push(keys[i]);
                    break;
            }
        }
        return path_parts.join('/');
    }

    function find_node(path) {
        let resolved_path = resolve_path(dir, path);
        let path_parts = resolved_path.split('/');
        let node = fs;
        for (let i = 0; i < path_parts.length; i++) {
            if (node === undefined) {
                break;
            }
            if (path_parts[i] !== '') {
                node = node.nodes[path_parts[i]];
            }
        }
        return node;
    }

    const programs = {
        'clear': function (args) {
            history = '';
        },
        'howdy': function (args) {
            write_line('hi there!');
        },
        'echo': function (args) {
            let buf = '';
            for (let i = 0; i < args.length; i++) {
                if (i > 0) {
                    buf += ' ';
                }
                buf += args[i]
            }
            write_line(buf);
        },
        'ls': function (args) {
            let path = args[0] || dir;
            path = resolve_path(dir, path);
            let node = find_node(path);
            if (node === undefined || node.type !== 'd') {
                write_line('not a directory: ' + path);
                return;
            }
            let keys = Object.keys(node.nodes);
            for (let i = 0; i < keys.length; i++) {
                write_line(keys[i]);
            }
        },
        'cd': function (args) {
            let path = args[0] || dir;
            path = resolve_path(dir, path);
            let node = find_node(path);
            if (node === undefined || node.type !== 'd') {
                write_line('not a directory: ' + path);
                return;
            }
            dir = path;
        },
        'pwd': function (args) {
            write_line(dir)
        },
        'cat': function (args) {
            let path = args[0] || dir;
            path = resolve_path(dir, path);
            let node = find_node(path);
            if (node === undefined || node.type !== 'f') {
                write_line('not a file: ' + path);
                return;
            }
            write_line(node.content);
        },
        'mkdir': function (args) {
            let path = args[0];
            if (path === undefined) {
                write_line('missing argument: path');
                return;
            }
            path = resolve_path(dir, path);
            let parent = path.substring(0, path.lastIndexOf('/'));
            let child = path.substring(path.lastIndexOf('/') + 1);
            let node = find_node(parent);
            if (node === undefined || node.type !== 'd') {
                write_line('not a directory: ' + path);
                return;
            }
            node.nodes[child] = {
                type: 'd',
                nodes: {}
            };
        }
    }

    const font_size = 14;
    const line_height = font_size + 5;
    let terminal = document.getElementById('terminal');
    terminal.width = document.body.offsetWidth;
    terminal.height = '300';
    ctx = terminal.getContext('2d');
    ctx.font = font_size + "px Courier New";
    ctx.font
    ctx.fillStyle = '#FFFFFF';

    let show_cursor = true;
    let blink_interval = setInterval(() => {
        show_cursor = !show_cursor;
    }, 600);

    function parse_command(cmd) {
        if (cmd.length === 0) {
            return [''];
        }
        let parts = []
        let buf = '';
        let quote = null;
        let quoted = false;
        for (let i = 0; i < cmd.length; i++) {
            switch (cmd[i]) {
                case "'":
                    if (quoted) {
                        if (quote === "'") {
                            quoted = false;
                            continue;
                        }
                    } else {
                        quoted = true;
                        quote = "'";
                        continue;
                    }
                    break;
                case '"':
                    if (quoted) {
                        if (quote === '"') {
                            quoted = false;
                            continue;
                        }
                    } else {
                        quoted = true;
                        quote = '"';
                        continue;
                    }
                    break;
            }

            if (quoted) {
                buf += cmd[i];
            } else {
                switch (cmd[i]) {
                    case ' ':
                        if (buf.length > 0) {
                            parts.push(buf);
                            buf = '';
                        }
                        break;
                    case '>':
                        parts.push(buf);
                        buf = '';
                        parts.push('>');
                        break;
                    case '|':
                        parts.push(buf);
                        buf = '';
                        parts.push('|');
                        break;
                    default:
                        buf += cmd[i];
                        break;
                }
            }
        }

        if (quoted) {
            return [];
        }

        if (buf.length > 0) {
            parts.push(buf)
        }
        return parts;
    }

    window.onkeydown = (e) => {
        clearInterval(blink_interval);
        show_cursor = true;
        switch (e.key) {
            case 'Enter':
                let command = text.substring(prefix().length);
                commands.push(command);
                let command_parts = parse_command(command);
                history += (text + '\n');
                if (command_parts[0] in programs) {
                    programs[command_parts[0]]((command_parts.slice(1)));
                } else {
                    history += 'command not found: ' + command_parts[0] + '\n';
                }
                text = prefix();
                break;
            case 'Backspace':
                text = text.substring(0, text.length - 1);
                if (text.length < prefix().length) {
                    text = prefix();
                }
                break;
            case 'Shift':
                break;
            case 'ArrowUp':
                cmdpos++;
                if (cmdpos > commands.length) {
                    cmdpos = commands.length;
                }
                text = prefix() + commands[commands.length - cmdpos];
                break;
            case 'ArrowDown':
                cmdpos--;
                if (cmdpos < 1) {
                    cmdpos = 0;
                    text = prefix();
                } else {
                    text = prefix() + commands[commands.length - cmdpos];
                }
                break;
            default:
                text += e.key;
                break;
        }
        blink_interval = setInterval(() => {
            show_cursor = !show_cursor;
        }, 600);
    };

    setInterval(() => {
        ctx.clearRect(0, 0, terminal.width, terminal.height);
        let cursor = show_cursor ? '_' : '';
        let lines = history.split('\n');
        let line_count = 0;
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].length > 0) {
                line_count += 1;
                ctx.fillText(lines[i], 5, line_height * (i + 1));
            }
        }
        ctx.fillText(text + cursor, 5, line_height * (line_count + 1));
    }, 10);

</script>
</body>
</html>